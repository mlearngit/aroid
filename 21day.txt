1.IO流（对象的序列化）

注意：
1.在堆内存中的对象能够被序列化
2.被static修饰的成员不会被序列化（因为静态都存在于方法区）
3.要想某个非静态的成员不被序列化，需要在其前加上关键字：transient
4.当某变量加上transient关键字后，当再反序列化时，被修饰的那个变量将获取不到（原因是该变量的生命周期仅限于调用时的内存中，而不会
在磁盘上持久化存在。它也没有被序列化到文件中保存）


一、序列化和反序列化的概念

　　把对象转换为字节序列的过程称为对象的序列化。
　　把字节序列恢复为对象的过程称为对象的反序列化。
　　对象的序列化主要有两种用途：
　　1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；
　　2） 在网络上传送对象的字节序列。

　　在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。
	比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，
	内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。

　　当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。
	发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。

二、JDK类库中的序列化API

　　java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，
	把得到的字节序列写到一个目标输出流中。
	
　　java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，
	并将其返回。
	
　　只有实现了Serializable和Externalizable接口的类的对象才能被序列化。Externalizable接口继承自 Serializable接口，
	实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。
	
　　对象序列化包括如下步骤：
　　1） 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；
　　2） 通过对象输出流的writeObject()方法写对象。

　　对象反序列化的步骤如下：
　　1） 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；
　　2） 通过对象输入流的readObject()方法读取对象。
	
	来源url:http://www.cnblogs.com/xdp-gacl/p/3777987.html
	

	
	其它注意：我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，
	若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，
	这与是否被transient修饰无关。



import java.io.*;

class ObjectStreamDemo{
	public static void main(String[] rgs)throws Exception{
		writeObj();
	}


	public static void readObj()throws Exception{
		ObjectInputStream  ois=new  ObjectInputStream(new FileInputStream("obj.txt"));

		Person  p=(Person)ois.readObject();

		System.out.println(p);

		ois.close();
	}

	public static void writeObj()throws IOException{
		ObjectOutputStream  oos=new ObjectOutputStream(new FileOutputStream("obj.txt"));
		oos.writeObject(new Person("lisi",39));
		oos.close();
	}
}

========================

import java.io.*;

class Person implements Serializable{

	public static final long serialVersionUID = 42L;

	private String name;
	transient int age;
	Person(String name,int age){
		this.name=name;
		this.age=age;
	}

	public String toString(){
		return name+":"+age;
	}
}






2.IO流（管道流）
1.之前的流在读取和写入时都有一个中转站，比如读取流把数据读进数组，再由写入流来操作
2.而管道流可以直接一边读一边写。只要把两要管道对接上就行。
3.通常情况下，管道流分别放到不同线程中去执行（不建议两对象使用单线程）
4.read()方法当没有读取到数据时就处于等待状态。
5.集合中涉及到io的是Properties;而io中涉及到多线程的是管道流。


import java.io.*;

class Read implements Runnable{
	private PipedInputStream in;
	Read(PipedInputStream in){
		this.in=in;
	}

	public void run(){
		try{	
			byte[] buf=new byte[1024];

			System.out.println("读取前...没有数据阻塞");

			int len=in.read(buf);

			System.out.println("读到数据...阻塞结束");


			String s=new String(buf,0,len);
			System.out.println(s);
			in.close();
		}catch(IOException e){
			throw new RuntimeException("read fail !");
		}

	}
}



class Write implements Runnable{
	private PipedOutputStream out;
	Write(PipedOutputStream out){
		this.out=out;
	}

	public void run(){
		try{	

			Thread.sleep(6000);
			out.write("piped  lai la".getBytes());
			out.close();
		}catch(IOException e){
			throw new RuntimeException("write fail !");
		}

	}
}


class PipedStreamDemo{
	public static void main(String[] args)throws IOException{
		PipedInputStream   in=new PipedInputStream();
		PipedOutputStream  out=new PipedOutputStream();
		in.connect(out);
		Read  r=new Read(in);
		Write w=new Write(out);
		new Thread(r).start();
		new Thread(w).start();
	}
}







3.IO流（RandomAccessFile）

RandomAccessFile）
该类不算是io体系中子类。
面是直接继承至Object。

但是它是IO包中成员，因为它具备读和写功能。
内部封装了一个数组，而且通过指针对数组的元素进行操作。
可以通过getFilePointer获取指针位置，
同时可以通过seek改变指针的位置。


其实完成读写的原理 就是内部封装了字节输入流和输出流。

通过构造函数可以看出，该类只能操作文件。